
- Новые карты должны создаваться, даже если им не передать параметров: `new Duck()` и `new Dog()`.
- Методы `quacks` и `swims` утки должны создаваться на уровне класса, а не добавляться в конструкторе.
- После добавления новых типов замени карты в колоде шерифа на уток, а в колоде бандита - на собак.
- Функция `isDuck` должна возвращать `true` для утки, а функция `isDog` — для собаки.
- Если все сделано правильно, то внизу карты утки должен быть текст Duck➔ Card, а у собаки Dog➔ Card.

Колоды для проверки:
```js
const seriffStartDeck = [
    new Duck(),
    new Duck(),
    new Duck(),
];
const banditStartDeck = [
    new Dog(),
];
```


3. «Утка или собака?»
Метод `getDescriptions` в `Card` создан для того, чтобы на картах появлялась дополнительная информация.
Его функционал хочется расширить. Причем так, чтобы это работало и для уток, и для собак,
и для всех остальных существ, которые будут добавляться.

- Создай новый тип `Creature` и унаследуй его от `Card`.
- Сделай так, чтобы `Duck` и `Dog` наследовались от `Creature`.
- Переопредели в классе `Creature` реализацию `getDescriptions` на новую.
  Теперь в ней должны возвращаться две строки описания в виде массива.
  Первая из них — из функции `getCreatureDescription`, которая определена в `index.js`.
  Вторая — из `getDescriptions` в `Card`.
  Для этого надо вызывать эту базовую версию функции `getDescriptions` из прототипа `Card`.
  В классах это делается просто: `super.getDescriptions()`;

  Заметь, что `getDescriptions` должен возвращать массив строк, а не просто строку!
  Верный признак, что ты напутал что-то с возвращаемым значением - вертикальная надпись на карте:
    У
    т
    к
    а
  Используй `spread-оператор` (так: `[newValue, ...values]`) или метод `unshift` массива,
  чтобы дополнить возвращаемый базовой версией `getDescriptions` массив новыми значениями.

Используя те же колоды, убедись, что у уток появилась надпись «Утка» над строкой с цепочкой наследования,
а у собак надпись «Собака» над цепочкой наследования.


4. «Громила»
Для уток все становится плохо, когда в рядах бандитов появляется Громила.

Добавь карту `Trasher`:
- называется Громила, сила 5, наследуется от `Dog`.
- если Громилу атакуют, то он получает на 1 меньше урона.

Подсказки:
- переопредели метод `modifyTakenDamage`, чтобы уменшать урон
- `this.view.signalAbility` — используй, чтобы при применении способности карта мигала
  Работает это так:
  `this.view.signalAbility(() => { // то, что надо сделать сразу после мигания. }`

Обрати внимание, что если Громиле нанести 2 урона,
то он сначала должен мигнуть «белым», потому что применилась способность и урон уменьшился на 1,
а затем мигнуть «красным» так как он все же получит единицу урона.
За красное мигание отвечает `signalDamage`, и он будет вызван сам в методе `takeDamage` в `Card.js`.

Переопредели `getDescriptions`, чтобы на лицевой стороне карты выводилось краткое описание способности Громилы.
Не забудь вызвать реализацию из базового типа, чтобы информация «Утка или Собака» никуда не делась!

Колоды для проверки:
```js
const seriffStartDeck = [
    new Duck(),
    new Duck(),
    new Duck(),
    new Duck(),
];
const banditStartDeck = [
    new Trasher(),
];
```


5. «Гатлинг»
Нехорошо нападать на мирных жителей. Это еще может быть опасно, если в сарае припрятан Гатлинг.

Добавь карту `Gatling`:
- называется Гатлинг, сила 6, наследуется от `Creature`.
- при атаке наносит 2 урона по очереди всем картам противника на столе, но не атакует игрока-противника.
  Таким образом урон сначала получает самая левая карта противника, затем вторая слева и так далее.
  Урон не должен наноситься одновременно.

Подсказки:
- переопредели метод `attack` так, чтобы урон наносился всем картам противника
- список карт противника можно получить через `gameContext.oppositePlayer.table`
- в качестве примера выполнения действий над несколькими картами можешь использовать `applyCards` из `Player.js`

Колоды для проверки:
```js
const seriffStartDeck = [
    new Duck(),
    new Duck(),
    new Duck(),
    new Gatling(),
];
const banditStartDeck = [
    new Trasher(),
    new Dog(),
    new Dog(),
];
```


6. «Братки»
Чем их больше, тем они сильнее.

Добавь карту `Lad`:
- называется Браток, сила 2, наследуется от `Dog`.
- чем больше братков находится в игре, тем больше урона без потерь поглощается
  и больше урона по картам наносится каждым из них.

Защита от урона      =  количество * (количество + 1) / 2
Дополнительный урон  =  количество * (количество + 1) / 2

Подсказки:
- текущее количество братков в игре надо где-то хранить, свойство в функции-конструкторе `Lad` — подходящее место.
  Заведи для этого пару методов:
    `static getInGameCount() { return this.inGameCount || 0; }`
    `static setInGameCount(value) { this.inGameCount = value; }`
  Хоть свойство `inGameCount` в функции `Lad`, другими словами статическое свойство класса `Lad`, явно не объявляется,
  при первом вызове `setInGameCount`, оно будет создано со значением `value`.
- чтобы обновлять количество братков в игре переопредели методы `doAfterComingIntoPlay`, `doBeforeRemoving`
- чтобы рассчитывать бонус к урону и защите стоит завести статический метод в классе `Lad`.
  Выглядеть будет как-то так: `static getBonus() { ... }`
  Чтобы в `getBonus` обращаться к другим статическим методам используй `this`, а не имя класса `Lad`.
  Вспомни, почему в статических методах в качестве `this` передается `Lad`.
- переопредели методы `modifyDealedDamageToCreature` и `modifyTakenDamage`, чтобы они использовали бонус.

Добавь в описание карты «Чем их больше, тем они сильнее».
Этот текст должен появляться только если непосредственно у братков (т.е. в `Lad.prototype`)
переопределены методы `modifyDealedDamageToCreature` или `modifyTakenDamage`.
Проверка на наличие свойства непосредственно у объекта выполняется с помщью метода `hasOwnProperty`.
Проверка наличия метода `modifyDealedDamageToCreature` у братков выглядит так:
    `Lad.prototype.hasOwnProperty('modifyDealedDamageToCreature')`
Эта особенность понадобится на следующем шаге.
Как видишь, даже при использовании `class` весь функционал прототипов доступен и работает.

Колоды для проверки:
```js
const seriffStartDeck = [
    new Duck(),
    new Duck(),
    new Duck(),
];
const banditStartDeck = [
    new Lad(),
    new Lad(),
];
```


